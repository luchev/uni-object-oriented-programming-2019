#include <iostream>
using namespace std;

int main() {
	// 1
	int A = 5;
	// 1.1
	cout << "A's value = " << A << endl;
	// 1.2
	cout << "A's address = " << &A << endl;

	// 2
	int* B = &A;
	// 2.1 Стойността на B е адрес, pointer-ите съхраняват адреса (виж 1.2), а не стойността
	cout << "B's value = " << B << endl;
	// 2.2
	cout << "The value of what B points = " << *B << endl;
	
	// 2.3
	// Стойностите съвпадат защото в момента B сочи към A
	// 2.4
	//в B е запазен адреса на A(който изведохме с &A), т.е B ако го разгледаме като един int 
	//той съдържа адреса на мястото, където се намира променливата А в паметта

	// 3 Заделяме динамична памет
	int* D = new int;
	// 3.1 
	cout << "D's value = " << D << endl;
	// 3.2 паметта, която D сочи е неинициализирана, но това не пречи да изведем стойността й
	cout << "The value of what D points = " << *D << endl;

	// 3.3
	// Стойността е случайна, т.е имаме недефинирано поведение (някои операционни системи ще е 0, 
	// на други ще е случайно число, не е описано в стандарта какво се случва в такъв случай от 
	// където идва израза недефинирано поведение)
	// 3.4
	// Компилатора на VS ни предпазва от използването на неинициализирани променливи (указателя 
	//също е неинициализирана променлива). Това не се случва при всички системи, някои компилатори 
	// позволяват да изведем стойността на неинициализирани променливи.
	// 3.5
	// Не може защото B не сочи динамична памет и ще гръмне, не може да трием статично заделена 
	// памет с delete

	// 3.6 Присвояваме стойност (D пак сочи същата променлива, променяме стойността на 
	// променливата, която сочи D)
	*D = 15;
	// 3.7
	cout << "The value of what D points = " << *D << endl;
	// 3.8
	cout << "The value of D = " << D << endl;

	// 4.1 B копира адреса, който е записан в D
	B = D;
	// 4.1 еквивалентно на горното, първо с * взимаме int-а, който сочи D, след това с & 
	// взимаме адреса на този int (който адрес всъщност е D)
	B = &(*D);
	
	// 4.2
	// Няма memory leak, защото B сочи статично заделената променлива A, която ще бъде 
	// изтрита в края на main

	// 4.3 Съвпада с *D защото сочи същия блок от памет (същия int)
	cout << "The value of what B points = " << *B << endl;
	// 4.4 Съвпада с D защото пази същия адрес
	cout << "The value of B = " << B << endl;
	// 4.5 B е променлива, чиято стойност е адрес, но B също си има адрес
	cout << "B's adderss = " << &B << endl;

	// 5.1 B вече е указател, ако искаме да създадем указател към B, то ще е двоен указател
	int** C = &B;
	// 5.2 Стойността на C е B, т.е адреса на D (виж 4.1)
	cout << "The value of what C points = " << *C << endl;
	// 5.3 Стойността на стойността на C е стойността на D
	cout << "The value of what double pointer C points to = " << **C << endl;
	/* Обяснение на последното
	* поставена пред указател може да мислим, че следва адреса на указателя
	т.е *C вижда какъв адрес сочи C и отива на него
	тогава **C [ еквивалентно на *(*C)) ] първо гледа какъв адрес сочи C
	C сочи B (от C сме се придвижили с * в B)
	при втория * (външния *) от B отиваме в това което сочи B
	но B сочи същото, което сочи D, а именно int със стойност 15 
	*/

	// 6.1 Изтриваме паметта, която сочи D
	delete D;
	// 6.2 B сочи мястото където е сочил преди (т.е заделената от D по-рано памет)
	cout << "The value of what B points = " << *B << endl;
	// 6.3 B запазва стойността си
	// 6.4 Тъй като изтрихме това, което сочеше D, B сочи някаква памет, която вече 
	// не ни принадлежи
	// 6.5 Не може да изтрием B защото не сочи памет, която сме заделили от програмата и 
	// нямаме достъп до нея за да я трием
	
	// 6.6
	int* E = new int[10];
	// 6.7
	E = B;

	// 6.8 Да има memory leak, защото никъде не пазим адреса на заделения масив от E в 
	// началото. Като не знаем адреса, не знаем къде да трием.

}
